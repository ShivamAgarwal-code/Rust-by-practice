1.
```rust
/* // Fix the error below with least amount of modification to the code
fn main() {
    let x: i32; // Uninitialized but used, ERROR !
    let y: i32; // Uninitialized but also unused, only a Warning !
    assert_eq!(x, 5);
    println!("Success!");
} */
fn main() {
    let x: i32 = 5; 
    let y: i32; 
    assert_eq!(x, 5);
    println!("Success!");
}
output: Success!
solution :initialise x
```
2.
```rust
/* // Fill the blanks in the code to make it compile
fn main() {
    let __ =  1;
    __ += 2; 
    
    assert_eq!(x, 3);
    println!("Success!");
} */
fn main() {
    let mut x =  1;
    x += 2; 
    
    assert_eq!(x, 3);
    println!("Success!");
}
output: Success!
solution: add mut since x is used twice
```
SCOPE

3.
```rust
/* // Fix the error below with least amount of modification
fn main() {
    let x: i32 = 10;
    {
        let y: i32 = 5;
        println!("The value of x is {} and value of y is {}", x, y);
    }
    println!("The value of x is {} and value of y is {}", x, y); 
} */
fn main() {
    let x: i32 = 10;
    
    {
        let y: i32 = 5;
        println!("The value of x is {} and value of y is {}", x, y);
    }
    println!("The value of x is {}", x); 
}
output:
The value of x is 10 and value of y is 5
The value of x is 10
solution: Remove y in the last println 
```
4.
```rust
/* // Fix the error with the use of define_x
fn main() {
    println!("{}, world", x); 
}
fn define_x() {
    let x = "hello";
} */
fn main() {
    let x = define_x();
    println!("{}, world", x); 
}
fn define_x() -> String{
    let x = "hello".to_string();
    x
}
output: hello, world
solution: add to_string() and declare x in main fn
```
